import { Audio, AVPlaybackStatus, AVPlaybackStatusSuccess, InterruptionModeIOS, InterruptionModeAndroid } from 'expo-av';
import { useAppStore } from '../store/appStore';
import { Platform, AppState, AppStateStatus } from 'react-native';
import * as MediaLibrary from 'expo-media-library';
import * as Notifications from 'expo-notifications';
import * as FileSystem from 'expo-file-system';

export class AudioPlayerService {
  private static instance: AudioPlayerService;
  private sound: Audio.Sound | null = null;
  private nextSound: Audio.Sound | null = null; // Para prebuffering de la siguiente canci√≥n
  private isInitialized = false;
  private currentLoadPromise: Promise<boolean> | null = null; // Promesa de carga actual
  private loadAbortController: AbortController | null = null; // Controlador para abortar cargas
  private remoteControlsEnabled = false;
  private appStateSubscription: any = null;
  private crossfadeEnabled = false; // Temporalmente deshabilitado para debug
  private crossfadeDuration = 2000; // 2 segundos de crossfade
  private prebufferTime = 10000; // Empezar a prebuffer 10 segundos antes del final
  private crossfadeInProgress = false; // Bandera para evitar m√∫ltiples crossfades

  private constructor() {}

  public static getInstance(): AudioPlayerService {
    if (!AudioPlayerService.instance) {
      AudioPlayerService.instance = new AudioPlayerService();
    }
    return AudioPlayerService.instance;
  }

  public async initialize() {
    if (this.isInitialized) return;
    
    try {
      // Configuraci√≥n espec√≠fica para aud√≠fonos Bluetooth
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: false,
        staysActiveInBackground: true,
        interruptionModeIOS: InterruptionModeIOS.DoNotMix,
        playsInSilentModeIOS: true,
        shouldDuckAndroid: true,
        interruptionModeAndroid: InterruptionModeAndroid.DoNotMix,
        playThroughEarpieceAndroid: false,
        // Configuraciones adicionales para mejorar compatibilidad con Bluetooth
        ...(Platform.OS === 'android' && {
          // Android espec√≠fico para Bluetooth
          audioWillChange: true,
        }),
        // Configuraciones para gapless playback
        ...(Platform.OS === 'ios' && {
          // iOS espec√≠fico para transiciones suaves
          mixWithOthers: false,
        }),
      });

      // Sincronizar configuraciones desde el store
      const store = useAppStore.getState();
      const { audioSettings } = store;
      this.crossfadeEnabled = audioSettings.crossfadeEnabled;
      this.crossfadeDuration = audioSettings.crossfadeDuration;
      this.prebufferTime = audioSettings.prebufferTime;

      // Configurar controles remotos para aud√≠fonos
      await this.setupRemoteControls();
      
      // Configurar listener para cambios de estado de la app
      this.setupAppStateListener();
      
      this.isInitialized = true;
      console.log('‚úÖ Audio player initialized successfully with Bluetooth remote controls');
      console.log(`üéµ Crossfade: ${this.crossfadeEnabled ? 'enabled' : 'disabled'} (${this.crossfadeDuration}ms)`);
      console.log(`üì¶ Prebuffer time: ${this.prebufferTime}ms`);
      console.log('üéß Bluetooth headphone controls should now work for:');
      console.log('  - Play/Pause: Toggle playback');
      console.log('  - Next: Skip to next track');
      console.log('  - Previous: Go to previous track');
      console.log('üì± Platform:', Platform.OS);
      
      if (__DEV__) {
        console.log('üîß Development mode notes:');
        console.log('  - Expo Go: Basic Bluetooth controls via expo-av');
        console.log('  - Development Build: Full media notification support');
        console.log('  - Use global.debugRemoteControls for testing');
      }
    } catch (error) {
      console.error('Error initializing audio player:', error);
      // Try a simpler configuration if the full one fails
      try {
        await Audio.setAudioModeAsync({
          allowsRecordingIOS: false,
          playsInSilentModeIOS: true,
          staysActiveInBackground: true,
        });
        
        // Intentar configurar controles remotos b√°sicos
        await this.setupRemoteControls();
        
        this.isInitialized = true;
        console.log('Audio player initialized with fallback configuration');
      } catch (fallbackError) {
        console.error('Failed to initialize audio player with fallback:', fallbackError);
      }
    }
  }

  private setupAppStateListener() {
    this.appStateSubscription = AppState.addEventListener('change', this.handleAppStateChange);
  }

  private handleAppStateChange = (nextAppState: AppStateStatus) => {
    if (nextAppState === 'background' || nextAppState === 'inactive') {
      // Mantener la reproducci√≥n activa en segundo plano
      this.ensureBackgroundPlayback();
    }
  };

  private async ensureBackgroundPlayback() {
    try {
      if (this.sound) {
        const status = await this.sound.getStatusAsync();
        if (status.isLoaded && status.isPlaying) {
          // Re-aplicar configuraci√≥n de audio para mantener conexi√≥n Bluetooth
          await Audio.setAudioModeAsync({
            allowsRecordingIOS: false,
            staysActiveInBackground: true,
            playsInSilentModeIOS: true,
            shouldDuckAndroid: false, // No reducir volumen en background
            interruptionModeAndroid: InterruptionModeAndroid.DoNotMix,
            playThroughEarpieceAndroid: false,
          });
        }
      }
    } catch (error) {
      console.error('Error ensuring background playback:', error);
    }
  }

  private async setupRemoteControls() {
    try {
      // Solo configurar en dispositivos reales, no en simulador
      if (Platform.OS === 'ios' && __DEV__) {
        console.log('Skipping remote controls setup in iOS simulator');
        return;
      }

      // Configurar handler para notificaciones locales (no push notifications)
      await Notifications.setNotificationHandler({
        handleNotification: async () => ({
          shouldShowAlert: false,
          shouldPlaySound: false,
          shouldSetBadge: false,
          shouldShowBanner: false,
          shouldShowList: false,
        }),
      });

      // Configurar canales de notificaci√≥n para Android (solo para controles de medios locales)
      if (Platform.OS === 'android') {
        try {
          await Notifications.setNotificationChannelAsync('media-controls', {
            name: 'Media Controls',
            importance: Notifications.AndroidImportance.LOW,
            sound: undefined,
            vibrationPattern: [],
            enableLights: false,
            description: 'Controls de medios para aud√≠fonos Bluetooth',
          });
          console.log('‚úÖ Android media control channel created');
        } catch (channelError) {
          console.warn('‚ö†Ô∏è Could not create notification channel (might be Expo Go limitation):', channelError);
          // Continuar sin notificaciones, los controles Bluetooth a√∫n pueden funcionar
        }
      }

      this.remoteControlsEnabled = true;
      console.log('‚úÖ Remote controls configured successfully for Bluetooth devices');
      console.log('‚ÑπÔ∏è Note: Media notifications may not work in Expo Go, but Bluetooth controls should work');
    } catch (error) {
      console.warn('‚ö†Ô∏è Error setting up remote controls (possibly Expo Go limitation):', error);
      console.log('üîÑ Falling back to basic Bluetooth controls via expo-av');
      this.remoteControlsEnabled = false;
    }
  }

  private async updateNowPlayingInfo(track: any) {
    try {
      if (!track || !this.remoteControlsEnabled) return;
      
      console.log('üéµ Updating Now Playing info for Bluetooth controls:');
      console.log('  - Title:', track?.title || 'Unknown track');
      console.log('  - Artist:', track?.artist || 'Unknown artist');
      console.log('  - Album:', track?.album || 'Unknown album');
      
      // expo-av maneja autom√°ticamente la informaci√≥n "Now Playing" 
      // para los controles de aud√≠fonos Bluetooth cuando:
      // 1. staysActiveInBackground: true est√° configurado
      // 2. El audio est√° reproduci√©ndose activamente
      // 3. Los metadatos est√°n disponibles en el archivo de audio
      
      console.log('üéß Bluetooth headphone controls should now work for play/pause/next/previous');
      
    } catch (error) {
      console.error('‚ùå Error updating now playing info:', error);
    }
  }

  // Funciones p√∫blicas para controlar crossfade
  public setCrossfadeEnabled(enabled: boolean) {
    this.crossfadeEnabled = enabled;
    // Actualizar el store
    const store = useAppStore.getState();
    store.updateAudioSettings({ crossfadeEnabled: enabled });
    console.log(`üéµ Crossfade ${enabled ? 'enabled' : 'disabled'}`);
  }

  public setCrossfadeDuration(durationMs: number) {
    this.crossfadeDuration = Math.max(1000, Math.min(5000, durationMs)); // Entre 1 y 5 segundos
    // Actualizar el store
    const store = useAppStore.getState();
    store.updateAudioSettings({ crossfadeDuration: this.crossfadeDuration });
    console.log(`‚è±Ô∏è Crossfade duration set to ${this.crossfadeDuration}ms`);
  }

  public setPrebufferTime(timeMs: number) {
    this.prebufferTime = Math.max(5000, Math.min(30000, timeMs)); // Entre 5 y 30 segundos
    // Actualizar el store
    const store = useAppStore.getState();
    store.updateAudioSettings({ prebufferTime: this.prebufferTime });
    console.log(`üì¶ Prebuffer time set to ${this.prebufferTime}ms`);
  }

  public async loadAndPlay(url: string) {
    try {
      console.log('üéµ Loading and playing:', url);
      
      // Validate URL
      if (!url || typeof url !== 'string') {
        throw new Error('Invalid URL provided');
      }
      
      // Stop and unload previous sound immediately
      if (this.sound) {
        try {
          await this.sound.stopAsync();
          await this.sound.unloadAsync();
          this.sound = null;
        } catch (error) {
          console.warn('Error stopping previous sound:', error);
        }
      }

      // Determinar si es un archivo local (offline) o URL remota
      const isLocalFile = url.startsWith('file://') || (FileSystem.documentDirectory && url.includes(FileSystem.documentDirectory));
      
      console.log('Audio source type:', isLocalFile ? 'Local file (offline)' : 'Remote stream');

      // Create and load new sound with minimal configuration
      const { sound } = await Audio.Sound.createAsync(
        { uri: url },
        { 
          shouldPlay: true,
          isLooping: false,
          volume: 1.0,
          progressUpdateIntervalMillis: 1000,
        },
        this.onPlaybackStatusUpdate.bind(this)
      );

      this.sound = sound;
      
      // Update player state immediately
      const store = useAppStore.getState();
      store.setPlayerState({ isPlaying: true });
      
      // Update Now Playing information
      const currentTrack = store.player.currentTrack;
      if (currentTrack) {
        this.updateNowPlayingInfo(currentTrack);
      }

      console.log('‚úÖ Audio loaded and playing successfully');
      return true;
    } catch (error) {
      console.error('‚ùå Error loading audio:', error);
      return false;
    }
  }

  private async _loadAndPlayInternal(url: string, signal: AbortSignal): Promise<boolean> {
    try {
      console.log('Loading track from URL:', url);
      
      // Validate URL
      if (!url || typeof url !== 'string') {
        throw new Error('Invalid URL provided');
      }

      // Verificar si fue cancelado antes de continuar
      if (signal.aborted) {
        throw new Error('Load was cancelled');
      }
      
      // Stop and unload previous sound completely
      await this.stopAndUnload();

      // Verificar si fue cancelado despu√©s de detener el audio anterior
      if (signal.aborted) {
        throw new Error('Load was cancelled');
      }

      // Determinar si es un archivo local (offline) o URL remota
      const isLocalFile = url.startsWith('file://') || (FileSystem.documentDirectory && url.includes(FileSystem.documentDirectory));
      
      console.log('Audio source type:', isLocalFile ? 'Local file (offline)' : 'Remote stream');

      // Create and load new sound
      const { sound } = await Audio.Sound.createAsync(
        { uri: url },
        { 
          shouldPlay: true,
          isLooping: false,
          volume: 1.0,
          progressUpdateIntervalMillis: 1000, // Update progress every second
        },
        this.onPlaybackStatusUpdate.bind(this)
      );

      // Verificar si fue cancelado despu√©s de crear el sonido
      if (signal.aborted) {
        console.log('Load was cancelled, unloading sound');
        await sound.unloadAsync();
        throw new Error('Load was cancelled');
      }

      this.sound = sound;
      
      // Resetear bandera de crossfade para la nueva canci√≥n
      this.crossfadeInProgress = false;
      
      // Actualizar informaci√≥n de "Now Playing" con el track actual
      const store = useAppStore.getState();
      const currentTrack = store.player.currentTrack;
      if (currentTrack) {
        await this.updateNowPlayingInfo(currentTrack);
      }
      
      console.log('Track loaded and playing successfully');
      
      return true;
    } catch (error: any) {
      if (signal.aborted || error?.message === 'Load was cancelled') {
        console.log('Audio load was cancelled');
        return false;
      }
      
      console.error('Error loading track:', error);
      console.error('URL was:', url);
      
      // Update store to reflect error state
      const store = useAppStore.getState();
      store.setPlayerState({ isPlaying: false });
      
      return false;
    }
  }

  public async play() {
    if (this.sound) {
      try {
        await this.sound.playAsync();
        useAppStore.getState().setPlayerState({ isPlaying: true });
        console.log('Playback started');
      } catch (error) {
        console.error('Error playing:', error);
      }
    }
  }

  public async pause() {
    if (this.sound) {
      try {
        await this.sound.pauseAsync();
        useAppStore.getState().setPlayerState({ isPlaying: false });
        console.log('Playback paused');
      } catch (error) {
        console.error('Error pausing:', error);
      }
    }
  }

  public async stop() {
    if (this.sound) {
      try {
        await this.sound.stopAsync();
        useAppStore.getState().setPlayerState({ isPlaying: false });
        console.log('Playback stopped');
      } catch (error) {
        console.error('Error stopping:', error);
      }
    }
  }

  public async stopAndUnload() {
    // Limpiar sonido actual
    if (this.sound) {
      try {
        await this.sound.stopAsync();
        await this.sound.unloadAsync();
        this.sound = null;
        useAppStore.getState().setPlayerState({ isPlaying: false });
        console.log('Playback stopped and unloaded');
      } catch (error) {
        console.error('Error stopping and unloading:', error);
      }
    }
    
    // Limpiar sonido prebuffering
    if (this.nextSound) {
      try {
        await this.nextSound.unloadAsync();
        this.nextSound = null;
        console.log('Next sound prebuffer cleared');
      } catch (error) {
        console.error('Error cleaning next sound:', error);
      }
    }
    
    // Resetear bandera de crossfade
    this.crossfadeInProgress = false;
  }

  public async seek(positionMillis: number) {
    if (this.sound) {
      try {
        await this.sound.setPositionAsync(positionMillis);
        console.log(`Seeked to ${positionMillis}ms`);
      } catch (error) {
        console.error('Error seeking:', error);
      }
    }
  }

  public async isPlaying(): Promise<boolean> {
    if (!this.sound) return false;
    
    try {
      const status = await this.sound.getStatusAsync();
      return status.isLoaded && (status as AVPlaybackStatusSuccess).isPlaying;
    } catch (error) {
      console.error('Error checking playing status:', error);
      return false;
    }
  }

  public async setVolume(volume: number) {
    if (this.sound) {
      try {
        await this.sound.setVolumeAsync(volume);
        console.log(`Volume set to ${volume}`);
      } catch (error) {
        console.error('Error setting volume:', error);
      }
    }
  }

  public async getStatus(): Promise<AVPlaybackStatus | null> {
    if (this.sound) {
      try {
        return await this.sound.getStatusAsync();
      } catch (error) {
        console.error('Error getting status:', error);
        return null;
      }
    }
    return null;
  }

  private onPlaybackStatusUpdate(status: AVPlaybackStatus) {
    try {
      if (status.isLoaded) {
        const successStatus = status as AVPlaybackStatusSuccess;
        
        // Update player state
        const store = useAppStore.getState();
        store.setPlayerState({
          position: successStatus.positionMillis || 0,
          duration: successStatus.durationMillis || 0,
          isPlaying: successStatus.isPlaying
        });
        
        // L√≥gica para gapless playback
        const position = successStatus.positionMillis || 0;
        const duration = successStatus.durationMillis || 0;
        
        if (duration > 0) {
          const timeRemaining = duration - position;
          
          // Prebuffer la siguiente canci√≥n cuando queden 10 segundos
          if (timeRemaining <= this.prebufferTime && timeRemaining > this.prebufferTime - 1000 && !this.nextSound) {
            this.prebufferNextTrack();
          }
          
          // Iniciar crossfade cuando queden exactamente los segundos configurados
          if (this.crossfadeEnabled && this.nextSound && !this.crossfadeInProgress && 
              timeRemaining <= this.crossfadeDuration && timeRemaining > this.crossfadeDuration - 500) {
            this.crossfadeInProgress = true;
            this.performCrossfade().then(success => {
              if (success) {
                // Actualizar al siguiente track
                const { queue, currentIndex } = store.player;
                if (queue.length && currentIndex !== undefined && currentIndex + 1 < queue.length) {
                  const nextTrack = queue[currentIndex + 1];
                  store.setPlayerState({ 
                    currentTrack: nextTrack,
                    currentIndex: currentIndex + 1 
                  });
                  
                  // Actualizar informaci√≥n de "Now Playing"
                  this.updateNowPlayingInfo(nextTrack);
                }
              }
              this.crossfadeInProgress = false;
            });
          }
        }
        
        // Check if track finished (fallback para cuando no hay crossfade)
        if (successStatus.didJustFinish && !successStatus.isLooping && !this.nextSound) {
          console.log('Track finished, playing next in queue');
          this.playNext();
        }
        
        // Manejar interrupciones de audio (llamadas, etc.)
        if (!successStatus.isPlaying && this.isInitialized) {
          // El audio fue pausado, posiblemente por una interrupci√≥n
          // expo-av maneja autom√°ticamente la reanudaci√≥n despu√©s de interrupciones
          console.log('Audio paused, possibly due to interruption');
        }
      } else {
        // Only log error if there's actually an error message
        if (status.error) {
          console.error('Playback status error:', status.error);
          // Reset player state on actual error
          const store = useAppStore.getState();
          store.setPlayerState({ isPlaying: false });
        }
        // If status.isLoaded is false but no error, it might be loading or transitioning
      }
    } catch (error) {
      console.error('Error in playback status update:', error);
    }
  }

  // Funci√≥n para prebuffer la siguiente canci√≥n
  private async prebufferNextTrack() {
    try {
      const store = useAppStore.getState();
      const { queue, currentIndex } = store.player;
      
      if (!queue.length || currentIndex === undefined) return;
      
      const nextIndex = currentIndex + 1;
      if (nextIndex >= queue.length) return; // No hay siguiente canci√≥n
      
      const nextTrack = queue[nextIndex];
      if (!nextTrack || !nextTrack.url) return;
      
      console.log('üîÑ Prebuffering next track:', nextTrack.title);
      
      // Limpiar cualquier sonido prebuffering anterior
      if (this.nextSound) {
        await this.nextSound.unloadAsync();
        this.nextSound = null;
      }
      
      // Crear el sonido para la siguiente canci√≥n (sin reproducir)
      const { sound } = await Audio.Sound.createAsync(
        { uri: nextTrack.url },
        { 
          shouldPlay: false, // No reproducir autom√°ticamente
          isLooping: false,
          volume: 0.0, // Empezar con volumen 0 para crossfade
          progressUpdateIntervalMillis: 500,
        }
      );
      
      this.nextSound = sound;
      console.log('‚úÖ Next track prebuffered successfully');
      
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to prebuffer next track:', error);
    }
  }

  // Funci√≥n para hacer crossfade entre canciones
  private async performCrossfade(): Promise<boolean> {
    if (!this.sound || !this.nextSound || !this.crossfadeEnabled) return false;
    
    try {
      console.log('üéµ Starting crossfade transition');
      
      // Obtener el volumen actual
      const currentStatus = await this.sound.getStatusAsync();
      if (!currentStatus.isLoaded) return false;
      
      const fadeSteps = 20; // N√∫mero de pasos para el fade
      const stepDuration = this.crossfadeDuration / fadeSteps;
      const volumeStep = 1.0 / fadeSteps;
      
      // Iniciar reproducci√≥n de la siguiente canci√≥n con volumen 0
      await this.nextSound.setVolumeAsync(0.0);
      await this.nextSound.playAsync();
      
      // Hacer crossfade
      for (let i = 0; i < fadeSteps; i++) {
        const currentVolume = 1.0 - (volumeStep * i);
        const nextVolume = volumeStep * i;
        
        await this.sound.setVolumeAsync(currentVolume);
        await this.nextSound.setVolumeAsync(nextVolume);
        
        await new Promise(resolve => setTimeout(resolve, stepDuration));
      }
      
      // Finalizar crossfade
      await this.sound.setVolumeAsync(0.0);
      await this.nextSound.setVolumeAsync(1.0);
      
      // Intercambiar los sonidos
      const oldSound = this.sound;
      this.sound = this.nextSound;
      this.nextSound = null;
      
      // Limpiar el sonido anterior
      await oldSound.unloadAsync();
      
      // Actualizar informaci√≥n de reproducci√≥n
      this.sound.setOnPlaybackStatusUpdate(this.onPlaybackStatusUpdate.bind(this));
      
      console.log('‚úÖ Crossfade completed successfully');
      return true;
      
    } catch (error) {
      console.error('‚ùå Error during crossfade:', error);
      return false;
    }
  }

  public async playNext() {
    try {
      const store = useAppStore.getState();
      const { queue, currentIndex } = store.player;
      
      console.log('playNext called - current state:', {
        queueLength: queue.length,
        currentIndex,
        currentTrack: store.player.currentTrack?.title
      });
      
      if (queue.length === 0) {
        // No queue - mantener reproduciendo la canci√≥n actual si existe
        console.log('No queue - keeping current track playing if exists');
        return;
      }

      // Asegurar que currentIndex tenga un valor v√°lido
      const safeCurrentIndex = typeof currentIndex === 'number' ? currentIndex : 0;
      const nextIndex = safeCurrentIndex + 1;
      
      console.log('playNext - calculated nextIndex:', nextIndex, 'from currentIndex:', safeCurrentIndex);
      
      if (nextIndex < queue.length) {
        const nextTrack = queue[nextIndex];
        
        // Validate next track
        if (nextTrack && nextTrack.id && nextTrack.url) {
          console.log('playNext - playing track:', nextTrack.title, 'at index:', nextIndex);
          // Update current index and track BEFORE loading
          store.setPlayerState({ 
            currentTrack: nextTrack,
            currentIndex: nextIndex 
          });
          // Play it
          await this.loadAndPlay(nextTrack.url);
        } else {
          // Invalid track, try to skip to next
          store.setPlayerState({ currentIndex: nextIndex });
          console.warn('Invalid track at index', nextIndex, ', skipping');
          await this.playNext(); // Recursive call to try next track
        }
      } else {
        // End of queue - mantener reproduciendo la canci√≥n actual
        console.log('End of queue reached - keeping current track playing');
        // No hacer nada, mantener la canci√≥n actual reproduci√©ndose
        return;
      }
    } catch (error) {
      console.error('Error in playNext:', error);
    }
  }

  public async playPrevious() {
    try {
      const store = useAppStore.getState();
      const { queue, currentIndex, position } = store.player;
      
      console.log('playPrevious called - current state:', {
        queueLength: queue.length,
        currentIndex,
        position: Math.floor(position || 0),
        currentTrack: store.player.currentTrack?.title
      });
      
      if (queue.length === 0) {
        console.log('No queue available for previous');
        return;
      }

      const safeCurrentIndex = typeof currentIndex === 'number' ? currentIndex : 0;
      const currentPosition = position || 0;
      
      // Si han pasado menos de 3 segundos desde el inicio de la canci√≥n
      if (currentPosition < 3000) { // 3000 ms = 3 segundos
        console.log('Less than 3 seconds, going to previous track');
        
        if (safeCurrentIndex > 0) {
          const prevIndex = safeCurrentIndex - 1;
          const prevTrack = queue[prevIndex];
          
          if (prevTrack && prevTrack.id && prevTrack.url) {
            console.log('playPrevious - going to track:', prevTrack.title, 'at index:', prevIndex);
            // Update current index and track BEFORE loading
            store.setPlayerState({ 
              currentTrack: prevTrack,
              currentIndex: prevIndex 
            });
            // Play it
            await this.loadAndPlay(prevTrack.url);
          } else {
            console.warn('Invalid previous track at index:', prevIndex);
            return;
          }
        } else {
          // Ya estamos en la primera canci√≥n
          console.log('Already at first track, restarting current track');
          await this.seek(0);
        }
      } else {
        // Han pasado m√°s de 3 segundos, reiniciar la canci√≥n actual
        console.log('More than 3 seconds elapsed, restarting current track');
        await this.seek(0);
      }
    } catch (error) {
      console.error('Error in playPrevious:', error);
    }
  }
        store.setPlayerState({ 
          currentTrack: prevTrack,
          currentIndex: prevIndex 
        });
        // Play it
        await this.loadAndPlay(prevTrack.url);
      } else {
        console.log('playPrevious - no valid previous track found, restarting current');
        if (this.sound) {
          await this.seek(0);
          await this.play();
        }
      }
    } catch (error) {
      console.error('Error in playPrevious:', error);
    }
  }

  public async playTrack(track: any) {
    console.log('AudioPlayer: playTrack called with track:', track.title);
    
    // Cancelar cualquier carga en progreso antes de iniciar nueva reproducci√≥n
    if (this.currentLoadPromise) {
      console.log('Cancelling current audio load for new track');
      if (this.loadAbortController) {
        this.loadAbortController.abort();
      }
    }

    await this.initialize(); // Asegurar que est√© inicializado
    
    const store = useAppStore.getState();
    store.setPlayerState({ currentTrack: track });
    
    console.log('AudioPlayer: Calling loadAndPlay with URL:', track.url);
    const result = await this.loadAndPlay(track.url);
    console.log('AudioPlayer: loadAndPlay completed with result:', result);
    return result;
  }

  // Reproduce una canci√≥n individual, reemplazando la cola actual
  public async playSingleTrack(track: any) {
    // Cancelar cualquier carga en progreso
    if (this.currentLoadPromise) {
      console.log('Cancelling current audio load for single track');
      if (this.loadAbortController) {
        this.loadAbortController.abort();
      }
    }

    const store = useAppStore.getState();
    
    // Reemplazar toda la cola con solo esta canci√≥n
    store.setQueue([track]);
    store.setPlayerState({ 
      currentTrack: track,
      currentIndex: 0 
    });
    
    return await this.loadAndPlay(track.url);
  }

  // Reproduce una lista (√°lbum, playlist, etc.) reemplazando la cola actual
  public async playTrackList(tracks: any[], startIndex: number = 0) {
    // Cancelar cualquier carga en progreso
    if (this.currentLoadPromise) {
      console.log('Cancelling current audio load for track list');
      if (this.loadAbortController) {
        this.loadAbortController.abort();
      }
    }

    const store = useAppStore.getState();
    
    if (!tracks || tracks.length === 0) {
      console.error('No tracks provided to play');
      return false;
    }

    // Validar √≠ndice de inicio
    const safeStartIndex = Math.max(0, Math.min(startIndex, tracks.length - 1));
    const trackToPlay = tracks[safeStartIndex];
    
    if (!trackToPlay || !trackToPlay.url) {
      console.error('Invalid track at index:', safeStartIndex);
      return false;
    }

    // Reemplazar toda la cola con la nueva lista
    store.setQueue(tracks);
    store.setPlayerState({ 
      currentTrack: trackToPlay,
      currentIndex: safeStartIndex 
    });

    console.log(`Playing track list: ${tracks.length} tracks, starting at index ${safeStartIndex}`);
    console.log('Initial track:', trackToPlay.title);
    return await this.loadAndPlay(trackToPlay.url);
  }

  // Agrega tracks a la cola actual (sin reemplazar)
  public async addToQueue(tracks: any[]) {
    const store = useAppStore.getState();
    const currentQueue = store.player.queue;
    const newQueue = [...currentQueue, ...tracks];
    store.setQueue(newQueue);
    console.log(`Added ${tracks.length} tracks to queue. Total: ${newQueue.length}`);
  }

  public async destroy() {
    // Limpiar listeners y recursos
    if (this.appStateSubscription) {
      this.appStateSubscription.remove();
      this.appStateSubscription = null;
    }
    
    // Cancelar cualquier carga en progreso
    if (this.loadAbortController) {
      this.loadAbortController.abort();
    }
    
    if (this.sound) {
      await this.sound.unloadAsync();
      this.sound = null;
    }
    
    this.isInitialized = false;
    this.currentLoadPromise = null;
    this.loadAbortController = null;
    this.remoteControlsEnabled = false;
    
    console.log('üßπ AudioPlayerService destroyed and cleaned up');
  }

  // M√©todos para manejar comandos remotos desde aud√≠fonos
  public async handleRemotePlay() {
    console.log('Remote play command received from headphones');
    await this.play();
  }

  public async handleRemotePause() {
    console.log('Remote pause command received from headphones');
    await this.pause();
  }

  public async handleRemoteNext() {
    console.log('Remote next command received from headphones');
    await this.playNext();
  }

  public async handleRemotePrevious() {
    console.log('Remote previous command received from headphones');
    await this.playPrevious();
  }

  // M√©todo para verificar si los controles remotos est√°n activos
  public isRemoteControlsEnabled(): boolean {
    return this.remoteControlsEnabled;
  }
}

// Export singleton instance
export const audioPlayer = AudioPlayerService.getInstance();
